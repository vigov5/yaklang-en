newResult = func( url, reqRaw, respRaw, param, payload) {
    return { "url": url,   "reqRaw": reqRaw, "respRaw": respRaw ,"param" : param, "payload":payload}
}

//checkErr Check for errors and exit
checkErr = func(err) {
    if err != nil {
        yakit.Output(sprintf("url-redirect-DETECT error: %s", err))
        os.Exit(1)
    }
}

redirectLog = func(result) {
    url = result.url
    param = result.param 
    reqRaw = result.reqRaw  
    respRaw = result.respRaw
    payload = result.payload
    msg = "Found url redirect"

    report = {"message": msg, "param":param}
    
    yakit_output(report)

    risk.NewRisk(
        url,
        risk.title(sprintf("URL redirect for: %v", url)),
        risk.details(report),
        risk.parameter(param),
        risk.description(`URL redirection vulnerability is a common web security vulnerability, also known as Open Redirect vulnerability. It usually occurs in web applications, and attackers can exploit this vulnerability to redirect users to a malicious website or URL to conduct phishing attacks, trick users into downloading malware, steal user sensitive information, conduct social engineering attacks, etc. The reason for the

URL redirection vulnerability is that the web application does not fully verify and verify the URL parameters provided by the user. Filtering allows the attacker to construct a malicious URL and redirect the user to a website or URL controlled by the attacker. The attacker can forge a page on the malicious website that is similar to the original website and trick the user into entering sensitive information, such as user name , passwords, credit card numbers, etc., or implant malicious code on the website, such as downloading malware or performing other attacks.`),
        risk.solution(`Input validation and filtering: Web applications should validate and filter input URL parameters and only allow redirects to trusted websites or URLs, or use a whitelist mechanism to limit redirect targets. For example, you can Verify that the protocol part of the URL is http or https, verify that the hostname is a trusted domain name, verify that the redirect target is under the applications domain name or subdomain, etc.

Use short URL services: Using short URL services can prevent long URLs from leaking users private and sensitive information, and can also reduce the risk of URL redirection vulnerabilities. The short URL service can convert long URLs into short URLs and map the short URLs to the original URLs. When users click on the short URLs, they will be redirected to the original URLs. URL shortening services typically verify and filter redirect targets, thereby reducing the risk of URL redirect vulnerabilities.

Secure Coding Practices: When developing web applications, you should Always pay attention to security and take appropriate security measures to protect user privacy and security. For example, you can use safe coding practices, use safe frameworks and libraries, conduct regular security audits and vulnerability scans, etc.`),
        risk.type("url redirect"),
        risk.request(reqRaw), 
        risk.payload(payload),
        risk.response(respRaw),
        risk.severity("warning"),
    )
    
}

inlocation = 1
inrefresh = 2
inmeta = 3
inlineScript =  4

paramNameList = ["redirect","redirect_to","redirect_url","url","jump","jump_to","target","to","link","linkto","domain","Out","Dout","go","return","returnTo","logout","register","login","returnUrl","path","redirectURI","redir","returl","share","wap","src","source","u","display","sourceURl","imageURL","linkurl","RedirectUrl","service","redirect_uri","destUrl","oauth_callback","oauth","goto","redirectUrl","callback","return_url","toUrl","ReturnUrl","fromUrl","redUrl","request"]

paramFilter = func (params){
    if len(params) == 0 {
        return params
    }
    res = []
    //Check suspicious parameter names and incoming parameter values that match the URL
    for param in params{
        if param.Name() in paramNameList{
            res.Append(param)
            continue
        }
        value, err = codec.DecodeUrl(param.Value()[0])
        die(err)
        if len(re.ExtractURL(value)) > 0 ||  len(re.ExtractPath(value)) > 0{
            res.Append(param)
        }
    }
    return res
}

jsAstCheck = func(statements,payload){
    for stat in statements{
        typ = js.GetSTType(stat)
        switch typ{
            case "ExpressionStatement":
                if expressionCheck(stat,payload){
                    return true
                }

        }
    }
    return false
}

expressionCheck = func(stat,payload){
    node = stat
    inerType = js.GetSTType(stat)
    if inerType == "ExpressionStatement"{
        inerType = js.GetSTType(stat.Expression)
        node = stat.Expression
    }
    switch inerType {
        case "CallExpression":
            if js.GetSTType(node.Callee) == "DotExpression"{
                if DotExprCheck(node,payload){
                    return true
                }
            }else if js.GetSTType(node.Callee) == "Identifier"{
                if node.Callee.Name == "setTimeout"{
                    if js.GetSTType(node.ArgumentList[0]) == "FunctionLiteral"{
                        if jsAstCheck(node.ArgumentList[0].Body.List,payload){
                            return true
                        }
                    }
                    if expressionCheck(node.ArgumentList[0],payload){
                        return true
                    }
                }

            }
        case "AssignExpression":
            if js.GetSTType(node.Left) == "DotExpression"{
                if AssignExprCheck(node,payload){
                    return true
                }
            }
    }
}



locationDotCode = ["window.location.replace","window.location.assign"]
locationAssignCode = ["window.location.href","window.location"]
DotExprCheck = func(stat,expect){
    expr = DotExprGeter(stat.Callee)
    if expr in locationDotCode{
        urlInfo,_ = str.ParseStringUrlToUrlInstance(stat.ArgumentList[0].Value )
        // printf("value:[%v]\n",stat.ArgumentList[0].Value)
        // printf("host:[%v]--expect:[%v]\n",urlInfo.Host,expect)
        if urlInfo.Host == expect{
            return true
        }
    }
}

AssignExprCheck = func(stat,expect){
    expr = DotExprGeter(stat.Left)
    if expr in locationAssignCode{
        urlInfo,_ = str.ParseStringUrlToUrlInstance(stat.Right.Value)
        if urlInfo.Host == expect{
            return true
        }
    }
}


DotExprGeter = func(expr){
    if js.GetSTType(expr.Left) == "Identifier"{
        return expr.Left.Name+"."+expr.Identifier.Name
    }else if js.GetSTType(expr.Left) == "DotExpression"{
        return DotExprGeter(expr.Left) +"."+ expr.Identifier.Name
    }else{
        return ""
    }
}

outputPosition  = func(rsp,sig_string){
    if !str.Contains(string(rsp),sig_string){
        return 0
    }

    headers = poc.GetHTTPPacketHeaders(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    if str.Contains(headers["Location"],sig_string){
        return inlocation
    }

    if str.Contains(headers["Refresh"],sig_string){
        return inrefresh
    }

    if str.Contains(headers["Content-Type"],"html"){

        html, err = xpath.LoadHTMLDocument(body)
        die(err)
        meta = xpath.Find(html, "//meta")
        scripts = xpath.Find(html, "//script")

        for m in meta {
            if str.EqualFold(xpath.SelectAttr(m, "http-equiv"), "refresh")&& str.Contains(xpath.SelectAttr(m, "content"),sig_string){
                return inmeta
            }
        }

        for script in scripts{
            if str.Contains(xpath.InnerText(script),sig_string){
                return inlineScript
            }
        }

    }
    return 0
}

makepayload = func (mark,value,host){
    res = make([]map[string]string,6)
    domain = host
    if len(str.ExtractDomain(value)) > 0 {
        domain = str.ExtractDomain(value)[0]
    }
    res[0] = {"payload":sprintf("//%s@%s", domain,mark),"expect":mark}
    res[1] = {"payload":sprintf("//%s?%s", mark,domain),"expect":mark}
    res[2] = {"payload":sprintf("//%s.%s", domain,mark),"expect":sprintf("%s.%s", domain,mark)}
    res[3] = {"payload":sprintf("//%s/%s",mark,domain ),"expect":mark}
    res[4] = {"payload":sprintf("//%s\\%s", mark,domain),"expect":mark}
    res[5] = {"payload":sprintf("//%s#%s", mark,domain),"expect":mark}
    return res
}

chromeUrlFix = func(url){
    return str.ReplaceAll(url,"\\","/")
}

Rawfuzz = func(param, fuzzPayload) {
    freq = param.Fuzz(fuzzPayload)
    rsp,err =  freq.ExecFirst()
    checkErr(err)

    return rsp.ResponseRaw
}
headerTask = func(req,param,ishttps,header){
    payloadDomain = str.RandStr(5) + ".com"
    pocData = makepayload(payloadDomain,param.Value,poc.GetHTTPPacketHeader(req,"Host"))
    for data in pocData{
        respRaw = Rawfuzz(param,data.payload)
        urlInfo,_ = str.ParseStringUrlToUrlInstance(poc.GetHTTPPacketHeader(respRaw, header))
        if urlInfo.Host == data.expect{
            return data.payload
        }
    }
    return nil
}

metaTask = func(req,param,ishttps){
    payloadDomain = str.RandStr(5) + ".com"
    pocData = makepayload(payloadDomain,param.Value,poc.GetHTTPPacketHeader(req,"Host"))
    for data in pocData{
        respRaw = Rawfuzz(param,data.payload)
        body = poc.GetHTTPPacketBody(respRaw)
        html, err = xpath.LoadHTMLDocument(body)
        die(err)
        meta = xpath.Find(html, "//meta")
        for m in meta {
            if str.EqualFold(xpath.SelectAttr(m, "http-equiv"), "refresh") {
                content = str.ToLower(xpath.SelectAttr(m, "content"))
                url = content.SplitN("url=",2)[1]
                urlInfo,_ = str.ParseStringUrlToUrlInstance(url)
                if str.EqualFold(urlInfo.Host,data.expect){
                    return data.payload
                }

            }

        }
    }

    return nil
}

scriptTask = func(req,param,ishttps){
    payloadDomain = str.RandStr(5) + ".com"
    pocData = makepayload(payloadDomain,param.Value,poc.GetHTTPPacketHeader(req,"Host"))
    for data in pocData{
        respRaw = Rawfuzz(param,data.payload)
        body = poc.GetHTTPPacketBody(respRaw)
        html, err = xpath.LoadHTMLDocument(body)
        die(err)
        scripts = xpath.Find(html, "//script")

        for s in scripts {
            code = xpath.InnerText(s)
            ast,err =  js.Parse(code)
            die(err)
            if jsAstCheck(ast.Body,data.expect){
                return data.payload
            }
        }
    }

    return nil
}




open_redirect_Detect = func(url, req, rsp, param, ishttps) {
    randStr = str.RandStr(10)
    originValue = param.Value()[0]
    respRaw= Rawfuzz(param,originValue+randStr)
    payloadParams = []
    position = outputPosition(respRaw,originValue+randStr)
    payload = nil
    println(position)
    switch position{
        case 0:
            return
        case inlocation :
            payload = headerTask(req,param,ishttps,"Location")
        case inrefresh :
            payload = headerTask(req,param,ishttps,"Refresh")
        case inmeta :
            payload = metaTask(req,param,ishttps)
        case inlineScript:
            payload = scriptTask(req,param,ishttps)
    }

    if payload != nil {
        redirectLog(newResult( url, req, rsp, param.Name(), payload))
    }
}


mirrorNewWebsitePathParams = func(ishttps, url, req, rsp, body) {
    dump(req)
    freq, err = fuzz.HTTPRequest(req, fuzz.https(ishttps))
    die(err)
    params =  freq.GetGetQueryParams()
    params = append(params, freq.GetPostParams()...)
    params = paramFilter(params)

    for param in params{
        open_redirect_Detect(url, req, rsp,param, ishttps)
    }
}