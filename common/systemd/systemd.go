package systemd

import (
	"bytes"
	"fmt"
	"github.com/yaklang/yaklang/common/log"
	"strconv"
)

/*
[TimerUnit]
Description=Example Service
Documentation=https://example.com/docs/example_service
After=network.target
Wants=some-other.service

[Service]
Type=simple
User=example-user
Group=example-group
ExecStart=/usr/bin/python3 /opt/example/example_script.py
TimeoutStartSec=30
Restart=on-failure
RestartSec=10
Environment=ENV_VAR1=value1 ENV_VAR2=value2

[Install]
WantedBy=multi-user.target


*/

func NewSystemServiceConfig(name string, opt ...ConfigOption) *SystemdServiceConfig {
	c := &SystemdServiceConfig{
		Name:            name,
		Description:     fmt.Sprintf("service[%s] is generated by yaklang", name),
		ServicesType:    "simple",
		User:            "root",
		Group:           "root",
		Restart:         "always",
		KillMode:        "mixed",
		KillSignal:      "SIGTERM",
		InstallWantedBy: "multi-user.target",
	}
	for _, p := range opt {
		p(c)
	}

	if c.ExecStart == "" && c.TimerUnit == "" {
		log.Warnf("service[%s] has no [Service]:ExecStart and [Timer]:Unit, it will not be started", name)
	}
	return c
}

func (c *SystemdServiceConfig) ToServiceFile() (string, string) {
	var fileName = c.Name
	if c.TimerUnit == "" {
		fileName += ".service"
	} else {
		fileName += ".timer"
	}

	var buf bytes.Buffer
	buf.WriteString("[Unit]\n")
	if c.Description == "" {
		c.Description = "service " + fileName
	}

	if c.Description != "" {
		buf.WriteString("Description=")
		buf.WriteString(c.Description)
		buf.WriteString("\n")
	}

	if c.Documentation != "" {
		buf.WriteString("Documentation=")
		buf.WriteString(c.Documentation)
		buf.WriteString("\n")
	}

	if c.After != "" {
		buf.WriteString("After=")
		buf.WriteString(c.After)
		buf.WriteString("\n")
	}

	if c.Before != "" {
		buf.WriteString("Before=")
		buf.WriteString(c.Before)
		buf.WriteString("\n")
	}

	if c.Requires != "" {
		buf.WriteString("Requires=")
		buf.WriteString(c.Requires)
		buf.WriteString("\n")
	}

	if c.BindsTo != "" {
		buf.WriteString("BindsTo=")
		buf.WriteString(c.BindsTo)
		buf.WriteString("\n")
	}

	if c.Wants != "" {
		buf.WriteString("Wants=")
		buf.WriteString(c.Wants)
		buf.WriteString("\n")
	}

	if len(c.UnitExtraLine) > 0 {
		for _, line := range c.UnitExtraLine {
			buf.WriteString(line)
			buf.WriteString("\n")
		}
	}

	buf.WriteString("\n")

	buf.WriteString("[Service]\n")

	if c.ServicesType != "" {
		buf.WriteString("Type=")
		buf.WriteString(c.ServicesType)
		buf.WriteString("\n")
	}

	if c.User != "" {
		buf.WriteString("User=")
		buf.WriteString(c.User)
		buf.WriteString("\n")
	}

	if c.Group != "" {
		buf.WriteString("Group=")
		buf.WriteString(c.Group)
		buf.WriteString("\n")
	}

	if c.ExecStart != "" {
		buf.WriteString("ExecStart=")
		buf.WriteString(c.ExecStart)
		buf.WriteString("\n")
	}

	if c.ExecStartPre != "" {
		buf.WriteString("ExecStartPre=")
		buf.WriteString(c.ExecStartPre)
		buf.WriteString("\n")
	}

	if c.ExecStartPost != "" {
		buf.WriteString("ExecStartPost=")
		buf.WriteString(c.ExecStartPost)
		buf.WriteString("\n")
	}

	if c.ExecStop != "" {
		buf.WriteString("ExecStop=")
		buf.WriteString(c.ExecStop)
		buf.WriteString("\n")
	}

	if c.ExecStopPost != "" {
		buf.WriteString("ExecStopPost=")
		buf.WriteString(c.ExecStopPost)
		buf.WriteString("\n")
	}

	if c.Restart != "" {
		buf.WriteString("Restart=")
		buf.WriteString(c.Restart)
		buf.WriteString("\n")
	}

	if c.RestartSec > 0 {
		buf.WriteString("RestartSec=")
		buf.WriteString(strconv.Itoa(int(c.RestartSec)))
		buf.WriteString("\n")
	}

	if c.Environment != "" {
		buf.WriteString("Environment=")
		buf.WriteString(c.Environment)
		buf.WriteString("\n")
	}

	if c.TimeoutStartSec > 0 {
		buf.WriteString("TimeoutStartSec=")
		buf.WriteString(strconv.Itoa(int(c.TimeoutStartSec)))
		buf.WriteString("\n")
	}

	if c.EnvironmentFile != "" {
		buf.WriteString("EnvironmentFile=")
		buf.WriteString(c.EnvironmentFile)
		buf.WriteString("\n")
	}

	if c.Umask != "" {
		buf.WriteString("Umask=")
		buf.WriteString(c.Umask)
		buf.WriteString("\n")
	}

	if c.StandardOutput != "" {
		buf.WriteString("StandardOutput=")
		buf.WriteString(c.StandardOutput)
		buf.WriteString("\n")
	}

	if c.StandardError != "" {
		buf.WriteString("StandardError=")
		buf.WriteString(c.StandardError)
		buf.WriteString("\n")
	}

	if c.StandardInput != "" {
		buf.WriteString("StandardInput=")
		buf.WriteString(c.StandardInput)
		buf.WriteString("\n")
	}

	if c.KillMode != "" {
		buf.WriteString("KillMode=")
		buf.WriteString(c.KillMode)
		buf.WriteString("\n")
	}

	if c.KillSignal != "" {
		buf.WriteString("KillSignal=")
		buf.WriteString(c.KillSignal)
		buf.WriteString("\n")
	}

	if c.ServiceExtraLine != nil {
		for _, line := range c.ServiceExtraLine {
			buf.WriteString(line)
			buf.WriteString("\n")
		}
	}
	buf.WriteString("\n")

	if c.TimerUnit != "" {
		buf.WriteString("[Timer]\n")
		if c.OnActiveSec > 0 {
			buf.WriteString("OnActiveSec=")
			buf.WriteString(strconv.Itoa(int(c.OnActiveSec)))
			buf.WriteString("\n")
		}

		if c.OnBootSec > 0 {
			buf.WriteString("OnBootSec=")
			buf.WriteString(strconv.Itoa(int(c.OnBootSec)))
			buf.WriteString("\n")
		}

		if c.OnStartupSec > 0 {
			buf.WriteString("OnStartupSec=")
			buf.WriteString(strconv.Itoa(int(c.OnStartupSec)))
			buf.WriteString("\n")
		}

		if c.OnUnitActiveSec > 0 {
			buf.WriteString("OnUnitActiveSec=")
			buf.WriteString(strconv.Itoa(int(c.OnUnitActiveSec)))
			buf.WriteString("\n")
		}

		if c.OnUnitInactiveSec > 0 {
			buf.WriteString("OnUnitInactiveSec=")
			buf.WriteString(strconv.Itoa(int(c.OnUnitInactiveSec)))
			buf.WriteString("\n")
		}

		if c.OnCalendar != "" {
			buf.WriteString("OnCalendar=")
			buf.WriteString(c.OnCalendar)
			buf.WriteString("\n")
		}

		if c.Persistent != "" {
			buf.WriteString("Persistent=")
			buf.WriteString(c.Persistent)
			buf.WriteString("\n")
		}

		if c.TimerUnit != "" {
			buf.WriteString("Unit=")
			buf.WriteString(c.TimerUnit)
			buf.WriteString("\n")
		}

		if c.TimerExtraLine != nil {
			for _, line := range c.TimerExtraLine {
				buf.WriteString(line)
				buf.WriteString("\n")
			}
		}
		buf.WriteString("\n")
	}

	buf.WriteString("[Install]\n")
	if c.InstallWantedBy != "" {
		buf.WriteString("WantedBy=")
		buf.WriteString(c.InstallWantedBy)
		buf.WriteString("\n")
	}

	buf.WriteString("\n")

	if c.Raw != "" {
		buf.WriteString(c.Raw)
		buf.WriteString("\n")
	}

	return fileName, buf.String()
}

type SystemdServiceConfig struct {
	Name string

	Description   string
	Documentation string
	After         string // Start after a certain service
	Before        string // Start in front of a service
	Requires      string // Strong dependency
	BindsTo       string // Bind to a certain service, strong dependency: When the bound service stops, this service also stops
	Wants         string // weak dependency
	UnitExtraLine []string

	// Default is simple
	/*
		simple (default): The command specified by ExecStart will start immediately and consider the service to have been started.
		forking: The process specified by ExecStart will fork itself, and the service will be considered to have been started after the parent process exits.
		oneshot: ExecStart The specified process will run and complete, and then the service will become inactive.
		dbus: After the service starts, it will wait for D-Bus Signal confirming that the service has started.
		notify: After the service is started, a notification will be sent through sd_notify to confirm that the service has been started.
		idle: similar to simple, but only starts the service when the system is idle.
	*/
	ServicesType     string // simple, forking, oneshot, dbus, notify, idle
	User             string
	Group            string
	ExecStart        string
	ExecStartPre     string
	ExecStartPost    string
	ExecStop         string
	ExecStopPost     string
	Restart          string // no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, always
	RestartSec       float64
	TimeoutStartSec  float64
	Environment      string
	EnvironmentFile  string
	Umask            string
	StandardInput    string // null, tty, tty-force, tty-fail, socket, fd, fd-force, fd-fail, file, file-force, file-fail
	StandardOutput   string // inherit, null, tty, journal, syslog, kmsg, journal+console, syslog+console, kmsg+console, socket, fd, file
	StandardError    string // inherit, null, tty, journal, syslog, kmsg, journal+console, syslog+console, kmsg+console, socket, fd, file
	KillMode         string // control-group, process, mixed, none
	KillSignal       string // The default should be -9
	ServiceExtraLine []string

	// Timer
	OnActiveSec       int64
	OnBootSec         int64
	OnStartupSec      int64
	OnUnitActiveSec   int64
	OnUnitInactiveSec int64
	OnCalendar        string
	TimerUnit         string
	TimerExtraLine    []string
	Persistent        string

	// Install
	InstallWantedBy string // Default is multi-user.target

	// Extra
	Raw string
}
