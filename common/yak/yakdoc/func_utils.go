package yakdoc

import (
	"fmt"
	"go/ast"
	"go/doc"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"strconv"
	"strings"

	"github.com/samber/lo"
	"github.com/yaklang/yaklang/common/utils"
)

type CacheAstBundle struct {
	fset       *token.FileSet
	pkg        *doc.Package
	parsedFile *ast.File
}

var (
	InterfaceToAnyRegep, _ = regexp.Compile(`interface\s*\{\}`)
	cacheAstBundleMap      = make(map[string]*CacheAstBundle) // filename -> CachePackage
	ErrAutoGenerated       = utils.Error("file is <autogenerated>")
	ErrIsInstanceMethod    = utils.Error("function is instance method")
)

func GetDeclAndCompletion(funcName string, params, results []*Field) (string, string) {
	// General processing params and results
	paramsStr := make([]string, 0, len(params))
	for i, p := range params {
		variadic := strings.HasPrefix(p.Type, "...")
		_ = variadic
		if p.Name == "" {
			p.Name = fmt.Sprintf("v%d", i+1)
		}
		p.Type = ShrinkTypeVerboseName(p.Type)

		/*
			Set vscode AutoCompletion
			vscode parameter completion format It is: ${n:default}
			n represents the cursor number: starting from 1, 0 is the end
			default is the default Supplementary value
		*/
		if variadic {
			paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v...}", i+1, p.Name))
		} else {
			if p.Type == "any" {
				paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v}", i+1, p.Name))
			} else {
				paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v /*type: %v*/}", i+1, p.Name, p.Type))
			}
		}
	}
	for i, r := range results {
		if r.Name == "" {
			results[i].Name = fmt.Sprintf("r%d", i+1)
		}
		r.Type = ShrinkTypeVerboseName(r.Type)
	}

	// generates declaration
	paramStr := strings.Join(lo.Map(params, func(p *Field, _ int) string {
		return fmt.Sprintf("%s %s", p.Name, p.Type)
	}), ", ")
	resultStr := ""
	if len(results) == 1 {
		if results[0].Name == "r1" {
			resultStr = results[0].Type
		} else {
			resultStr = fmt.Sprintf("(%s %s)", results[0].Name, results[0].Type)
		}
	} else if len(results) > 0 {
		resultStr = fmt.Sprintf("(%s)", strings.Join(lo.Map(results, func(r *Field, i int) string {
			if r.Name == fmt.Sprintf("r%d", i+1) {
				return r.Type
			}
			return fmt.Sprintf("%s %s", r.Name, r.Type)
		}), ", "))
	}
	declaration := fmt.Sprintf("%s(%s) %s", funcName, paramStr, resultStr)
	declaration = strings.TrimSpace(declaration)
	completion := strings.Join(paramsStr, ", ")
	completion = fmt.Sprintf("%v(%v)", funcName, completion)
	return declaration, completion
}

func GetCacheAstBundle(fileName string) (*CacheAstBundle, error) {
	var (
		cacheAstBundle *CacheAstBundle
		ok             bool
	)
	if cacheAstBundle, ok = cacheAstBundleMap[fileName]; !ok {
		fset := token.NewFileSet()

		// Parse src
		parsedAst, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments|parser.AllErrors)
		if err != nil {
			return nil, utils.Errorf("parse source file error: %v", err)
		}

		pkg := &ast.Package{
			Name:  "Any",
			Files: make(map[string]*ast.File),
		}
		pkg.Files[fileName] = parsedAst

		importPath, _ := filepath.Abs(fileName)
		docPkg := doc.New(pkg, importPath, doc.AllDecls)

		cacheAstBundle = &CacheAstBundle{
			fset:       fset,
			pkg:        docPkg,
			parsedFile: parsedAst,
		}

		cacheAstBundleMap[fileName] = cacheAstBundle
	}
	return cacheAstBundle, nil
}

// rename native type
func ShrinkTypeVerboseName(i string) string {
	if InterfaceToAnyRegep.MatchString(i) {
		return InterfaceToAnyRegep.ReplaceAllString(i, "any")
	}
	if i == "[]uint8" {
		return "[]byte"
	}

	return i
}

func GetTypeName(expr ast.Expr, fset *token.FileSet) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + GetTypeName(t.X, fset)
	case *ast.SelectorExpr:
		return GetTypeName(t.X, fset) + "." + t.Sel.Name
	case *ast.InterfaceType:
		return "any"
	case *ast.Ellipsis:
		return "..." + GetTypeName(t.Elt, fset)
	case *ast.ArrayType:
		return "[]" + GetTypeName(t.Elt, fset)
	case *ast.MapType:
		return "map[" + GetTypeName(t.Key, fset) + "]" + GetTypeName(t.Value, fset)
	default:
		var buf strings.Builder
		err := format.Node(&buf, fset, expr)
		if err != nil {
			return ""
		}
		return buf.String()
	}
}

func HandleParams(funcRefType reflect.Type, typ *ast.FuncType, fset *token.FileSet) (params []*Field) {
	if typ.Params == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			params = nil
		}
	}()
	params = make([]*Field, 0, len(typ.Params.List))
	canRef := !utils.IsNil(funcRefType)

	for i, field := range typ.Params.List {
		var fieldRefType reflect.Type
		if canRef {
			fieldRefType = funcRefType.In(i)
		}

		typName := ShrinkTypeVerboseName(GetTypeName(field.Type, fset))
		for _, name := range field.Names {
			param := &Field{
				Name: name.Name,
				Type: typName,
			}
			if canRef {
				param.RefType = fieldRefType
			}
			params = append(params, param)
		}
	}
	return params
}

func HandleResults(funcRefType reflect.Type, typ *ast.FuncType, fset *token.FileSet) (results []*Field) {
	if typ.Results == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			results = nil
		}
	}()
	results = make([]*Field, 0, len(typ.Results.List))
	canRef := !utils.IsNil(funcRefType)

	for i, field := range typ.Results.List {
		var fieldRefType reflect.Type
		if canRef {
			fieldRefType = funcRefType.Out(i)
		}

		typName := ShrinkTypeVerboseName(GetTypeName(field.Type, fset))

		for _, name := range field.Names {
			result := &Field{
				Name: name.Name,
				Type: typName,
			}
			if canRef {
				result.RefType = fieldRefType
			}
			results = append(results, result)
		}
		// Handle the situation without real-name return value
		if len(field.Names) == 0 {
			result := &Field{
				Name: "",
				Type: typName,
			}
			if canRef {
				result.RefType = fieldRefType
			}
			results = append(results, result)
		}
	}
	return results
}

func HandleFieldsRaw(fieldStr string) []*Field {
	fieldStrs := strings.Split(fieldStr, ",")
	ret := make([]*Field, 0, len(fieldStr))
	tempFields := make([]*Field, 0)
	for _, r := range fieldStrs {
		r = strings.TrimSpace(r)
		if r == "" {
			continue
		}
		splited := strings.Split(r, " ")
		// . It is generally believed that there must be a variable name, so the first one that is split must be the variable name
		if len(splited) < 2 {
			field := &Field{
				Name: splited[0],
			}
			ret = append(ret, field)
			tempFields = append(tempFields, field)
		} else {
			name, typ := splited[0], splited[1]
			ret = append(ret, &Field{
				Name: name,
				Type: typ,
			})
			if len(tempFields) > 0 {
				for _, field := range tempFields {
					field.Type = typ
				}
				tempFields = make([]*Field, 0)
			}
		}
	}
	return ret
}

func customHandleParamsAndResults(libName string, overideName string, params []*Field, results []*Field) ([]*Field, []*Field) {
	// Discard the first parameter when eval, because the first parameter is context, which is automatically injected during execution
	// if libName == "__GLOBAL__" && overideName == "eval" {
	// 	params = params[1:]
	// }
	return params, results
}

// Get description and declaration of a func
func FuncToFuncDecl(f interface{}, libName string, overideName string) (*FuncDecl, error) {
	funcRefValue := reflect.ValueOf(f)
	funcRefType := funcRefValue.Type()
	if funcRefValue.Kind() != reflect.Func {
		return nil, fmt.Errorf("not a function")
	}
	pc := funcRefValue.Pointer()
	if pc == 0 {
		return nil, fmt.Errorf("cannot get function pointer")
	}
	function := runtime.FuncForPC(pc)
	if function == nil {
		return nil, fmt.Errorf("cannot get function from runtime")
	}

	var (
		docPkg *doc.Package
		fset   *token.FileSet
		err    error

		declaration string
		document    string
		completion  string
		params      []*Field
		results     []*Field
	)

	filename, line := function.FileLine(0)
	splitFuncName := strings.Split(function.Name(), ".")
	funcName := splitFuncName[len(splitFuncName)-1]
	if strings.HasSuffix(funcName, "-fm") {
		return nil, ErrIsInstanceMethod
	}
	if filename == "<autogenerated>" {
		return nil, ErrAutoGenerated
	}

	bundle, err := GetCacheAstBundle(filename)
	if err != nil {
		return nil, err
	}
	fset, docPkg = bundle.fset, bundle.pkg

	found := false

	buf, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	funcs := docPkg.Funcs
	for _, theType := range docPkg.Types {
		funcs = append(funcs, theType.Methods...)
		funcs = append(funcs, theType.Funcs...)
	}
	lo.Uniq(funcs)

	for _, theFunc := range funcs {
		if theFunc.Name != funcName {
			continue
		}
		position := fset.Position(theFunc.Decl.Pos())
		if position.Line != line {
			continue
		}

		found = true

		decl := theFunc.Decl
		// should not appear Get function comments
		document = theFunc.Doc
		// // . Delete CRLF
		// document = strings.ReplaceAll(document, "\r", "")
		// document = strings.ReplaceAll(document, "\n", "")

		// Get parameters
		if decl != nil && decl.Type != nil && decl.Type.Params != nil {
			params = HandleParams(funcRefType, decl.Type, fset)
		}

		// Get the return value
		if decl != nil && decl.Type != nil && decl.Type.Results != nil {
			results = HandleResults(funcRefType, decl.Type, fset)
		}

		break
	}

	// tries to find
	if !found {
		for _, v := range docPkg.Vars {
			decl := v.Decl
			if decl == nil {
				continue
			}
			if len(decl.Specs) == 0 {
				continue
			}
			iSpec := decl.Specs[0]
			spec, ok := iSpec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			if len(spec.Values) == 0 {
				continue
			}
			iValue := spec.Values[0]
			value, ok := iValue.(*ast.CompositeLit)
			if !ok {
				continue
			}

			iType := value.Type
			_, ok = iType.(*ast.MapType)
			if !ok {
				continue
			}
			for _, elt := range value.Elts {
				kv, ok := elt.(*ast.KeyValueExpr)
				if !ok {
					continue
				}
				key, ok := kv.Key.(*ast.BasicLit)
				if !ok {
					continue
				}
				keyStr, err := strconv.Unquote(key.Value)
				if err != nil {
					continue
				}
				if strings.ToLower(keyStr) != strings.ToLower(funcName) && keyStr != overideName {
					continue
				}

				// . Processing "asd" => in the map When referencing other functions
				v, ok := kv.Value.(*ast.Ident)
				if ok {
					obj := v.Obj
					if obj == nil {
						continue
					}
					decl := obj.Decl
					if decl == nil {
						continue
					}
					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						params = HandleParams(funcRefType, funcDecl.Type, fset)
						results = HandleResults(funcRefType, funcDecl.Type, fset)
						found = true
						break
					}

					// . Processing "asd" => . Reference variable => function situation
					if specs, ok := decl.(*ast.ValueSpec); ok {
						if len(specs.Values) == 0 {
							continue
						}
						funcLit, ok := specs.Values[0].(*ast.FuncLit)
						if ok {
							params = HandleParams(funcRefType, funcLit.Type, fset)
							results = HandleResults(funcRefType, funcLit.Type, fset)
							found = true
							break
						}
					}
				}

				// . Processing "asd" => anonymous function situation
				funcLit, ok := kv.Value.(*ast.FuncLit)
				if ok {
					params = HandleParams(funcRefType, funcLit.Type, fset)
					results = HandleResults(funcRefType, funcLit.Type, fset)
					found = true
					break
				}

				// handles the situation of calling a function to obtain a function
				callExpr, ok := kv.Value.(*ast.CallExpr)
				if !ok {
					continue
				}
				fun, ok := callExpr.Fun.(*ast.Ident)
				if !ok {
					continue
				}
				obj := fun.Obj
				if obj == nil {
					continue
				}
				decl := obj.Decl
				if decl == nil {
					continue
				}
				// parses the first one The return value is the function type
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					typ := funcDecl.Type
					if typ == nil {
						continue
					}
					rets := typ.Results
					if rets == nil {
						continue
					}
					if rets.List == nil || len(rets.List) != 1 {
						continue
					}
					field := rets.List[0]
					if field == nil {
						continue
					}
					typExpr := field.Type
					if typ, ok = typExpr.(*ast.FuncType); !ok {
						continue
					}
					params = HandleParams(funcRefType, typ, fset)
					results = HandleResults(funcRefType, typ, fset)
					found = true
					break
				}

				// Logically speaking, "asd" => In the case of utils.xxx, because it has been dealt with above, the situation may be due to the duplicate name

				_ = decl
			}

			if found {
				break
			}
		}
	}

	// The final fallback cannot get the variable name and return name, try to directly parse the string
	if !found {
		lines := strings.Split(string(buf), "\n")
		if line >= len(lines) {
			return nil, fmt.Errorf("line out of range")
		}
		lineStr := lines[line-1]
		lineStr = ShrinkTypeVerboseName(lineStr)
		// removes comments
		if commentIndex := strings.Index(lineStr, "//"); commentIndex != -1 {
			lineStr = lineStr[:commentIndex]
		}
		// removes the string before func
		if index := strings.Index(lineStr, "func "); index != -1 {
			lineStr = lineStr[index:]
		}
		// is a structure method
		if strings.HasPrefix(lineStr, "func (") {
			lineStr = lineStr[strings.Index(lineStr, ")")+1:]
		}
		// Remove the string before assignment
		if strings.Contains(lineStr, "=") {
			lineStr = lineStr[strings.Index(lineStr, "=")+1:]
		}
		if strings.Contains(lineStr, ":") {
			lineStr = lineStr[strings.Index(lineStr, ":")+1:]
		}
		// Remove spaces
		lineStr = strings.TrimSpace(lineStr)
		// removes return
		lineStr = strings.TrimPrefix(lineStr, "return ")
		// Remove func
		lineStr = strings.TrimPrefix(lineStr, "func")
		// Remove spaces
		lineStr = strings.TrimSpace(lineStr)
		// . Remove the left Curly braces
		index := strings.Index(lineStr, "{")
		if index != -1 {
			lineStr = lineStr[:index]
		}
		// Get parameters
		if paramsIndex := strings.Index(lineStr, "("); paramsIndex != -1 {
			paramsStr := lineStr[paramsIndex+1:]
			paramsEndIndex := strings.Index(paramsStr, ")")
			if paramsEndIndex != -1 {
				paramsStr = paramsStr[:paramsEndIndex]
			}
			paramsStr = strings.TrimRight(paramsStr, ")")
			paramsStr = strings.TrimSpace(paramsStr)

			params = HandleFieldsRaw(paramsStr)
			paramsEndIndex = strings.Index(lineStr, ")")
			if paramsEndIndex != -1 {
				if paramsEndIndex+2 < len(lineStr) {
					lineStr = lineStr[paramsEndIndex+2:]
				} else {
					lineStr = ""
				}
			}
		}
		// Get the return value
		if resultsIndex := strings.Index(lineStr, "("); resultsIndex != -1 {
			// Multiple return values 
			resultsStr := lineStr[resultsIndex+1:]
			resultEndIndex := strings.Index(resultsStr, ")")
			if resultEndIndex != -1 {
				resultsStr = resultsStr[:resultEndIndex]
			}
			resultsStr = strings.TrimRight(resultsStr, ")")
			resultsStr = strings.TrimSpace(resultsStr)

			results = HandleFieldsRaw(resultsStr)
		} else {
			// single return value
			resultsStr := strings.TrimSpace(lineStr)
			results = append(results, &Field{
				Name: "",
				Type: resultsStr,
			})
		}
	}

	finalName := overideName
	if finalName == "" {
		finalName = funcName
	}

	// Special processing params and results
	// params, results = customHandleParamsAndResults(libName, overideName, params, results)

	declaration, completion = GetDeclAndCompletion(finalName, params, results)

	// Special processing Document
	if document != "" {
		exampleIndex := strings.Index(document, "Example:")
		if exampleIndex != -1 {
			document = strings.ReplaceAll(document[:exampleIndex], "\n", "\n\n") + document[exampleIndex:]
		}
	}

	return &FuncDecl{
		LibName:        libName,
		MethodName:     finalName,
		Document:       document,
		Decl:           declaration,
		Params:         params,
		Results:        results,
		VSCodeSnippets: completion,
	}, nil
}
